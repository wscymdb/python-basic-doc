# 1.内建常用的数据类型

* 序列（sequence）类型
  * 字符串str、字节序列bytes、bytearry
  * 列表list、元组tuple
* 键值对
  * 集合set、字典dict

# 2.线性数据结构

## 2.1.线性表

​	简称表，是一种抽象的数学概念，是一组元素的```序列```的抽象，由有穷个元素组成（0个或任意个）

序列：可以编号的，但是不一定是顺序的

分为顺序表和链接表

* 顺序表：使用一大块```连续的内存储```表中的元素，这样实现的表称之为顺序表，或称连续表（内存是连续编地址的，顺序表就是利用这点，所以速度块）
  * 在顺序表中，元素的关系使用顺序表的存储顺序自然地表示
* 链接表：在```存储空间中```将```分散存储```的元素链接起来，这种实现称为链接表，简称```链表```
  * 链表是线性结构，内存分布上看着不连续，但是内部有指向，前一个元素指向下一个元素，所以他是有明确顺序的

# 3.列表list

* 属于线性表的```顺序表```
* 使用```[]```表示
* 元素可以是任意对象
* 列表是可索引的，从索引从```0```开始
* 列表是``可变的``

## 3.2.列表的初始化

* []    空列表
* list()  空列表
* [1,2,'a',True]
* list()
  * 括号中写可迭代对象

```python
l1 = []  # []
l2 = list() #[]
l3 = [1,2,3,'a'] # [1,2,3,'a']
l4 = list(range(3)) # [0，1，2]
# 从range(3)中遍历所有元素，组成一个新的列表，然后返回给14
l5 = list([1,'a']) # [1,'a']
# 从[1,'a']中遍历所有元素，组成一个新的列表，然后返回给15
```

## 3.3.索引

* 有负的索引，从-1开始
* 正索引从0开始，索引范围[0, length-1]
* 索引超出list的length，会抛出异常
* 用索引访问list的元素，``效率高``，时间复杂度为``O(1)``

```python
l1 = [1, 2, 'a', True, None]
print(l1[-1]) # None
print(l1(6))  # TypeError: 'list' object is not callable
```

## 3.4.查询

* 遍历元素都跟当前遍历的例表的数据的个数有关，元素多称为``规模大``,反之称为``规模小``
* O(1) ：1是一个``常数``，可以是一步或者``固定的几步``，与规模n无关，不会随着规模n的增加而影响效率
* O(n)  ：耗时随着n的规模增加而增加

### 3.4.1.index

使用：

* index(value [,start [,stop] ] )
* 通过值value，从指定区间查找列表内的元素是否匹配
* 匹配第一个就立即返回索引
* 匹配不到，抛出异常``ValueError``

```python 
l1 = [1, 2, 2, 'a', None]
idx = l1.index('a')
# 2
```



总结：

* 耗时随着数据规模的增加而增加
* 效率随着规模的增加而下降,效率``极差``
* 时间复杂度是``O(n)``
* ``数据规模大时，不推荐使用``

### 3.4.2count

使用:

* count(value)
* 返回列表中匹配value的次数

总结：

* 不管有多少元素都需要完整的遍历一遍
* 数据规模有多大，耗时就有多久，效率也就``极差``
* 时间复杂度是``O(n)``
* ``数据规模大时，不推荐使用``

```python
l1 = [1, 2, 2, 'a', None]
cnt = l1.count(2)
# 2
```



### 3.4.3.len

获取当前list的长度，时间复杂度是``O(1)``

时间复杂度是O(1)的原因：

​	因为len()不是通过遍历list去获取长度的，而是包装c语言的数组，每当list中``新增``一个元素就让list的``长度+1``，如果``删除``的话就``让长度-1``，所以当调用len的时候，就会直接返回长度了

```python
l1 = [1,2,3]
len(l1) # 3
```

## 3.5.修改

* 通过索引定位到元素，然后直接赋值即可，注意索引不能超界
* ``时间复杂度是O(1)``

```python
ls1 = [1,2,3]
ls1[0] = 9
# [9, 2, 3]
```

## 3.6.增加单个元素

### 3.6.1.append （尾部追加）

```python
ls1 = [1, 2]
ls1.append(1)
# [1,2,1]
```



append函数没有返回值，返回值是None（一般说没有返回值），没有返回值往往表示它自己被改变了，``就地修改``

* 在元素``内部尾部``追加

**时间复杂度：**

``列表原理``

​	列表是一个容器，他是有容量的，python中列表可以扩大，自动扩大，会先给初始的大小，不够了会扩容，每次扩增的倍数是2倍。

**添加元素分为两种情况**

* 情况一
  * 列表的容量够时，通过找到下标，直接在内部尾部追加，此时的``时间复杂度是O(1)``

* 情况二
  * 列表容量不够时，会先将列表的容量进行扩充，在执行添加操作，此时的``时间复杂度是O(n)``。

**扩容时分为两种情况**

* 情况一：连续内存够时
  * 因为列表时顺序表，顺序表的特点是在内存中找到连续内存，当列表需要扩容时，如果当前连续内存后面还有未被使用的内存时，那么直接扩容
* 情况二：连续内存不够时
  * 当扩容时，如果当前内存后面没有空闲的内存时，那么就涉及到python的垃圾回收机制了，扩容会等到垃圾回收机制将当前连续的内存后面的内容清理出来，才会执行扩容行为，这个等待的时间时耗时的，所以效率就低了

总结：

* 一般情况下，定位效率高
* 定位（通过下标找到元素）

### 3.6.2.insert

* insert(index, object)
* 在索引index的``前面插入``object
* 超界（右边），相当于append的效果
* 超界（左边），插入的元素在下标为0的地方显示

```python

ls1 = [1, 2, 3]
ls1.insert(-1, 'p')
# [1, 2, 'p', 3]
ls1.insert(1, 'p')
# [1, 'p', 2, 3]

# 超右边界
ls1.insert(100, 'p')
# [1, 2, 3, 'p']

# 超左边界
ls1.insert(-100, 'p')
# ['p', 1, 2, 3]
```

总结

* insert的定位效率高
* 插入点之后有数据向后挪动，效率极低。
* 规模越大，挪动数据越多
* 最差的情况，插入到队首
* 最好的情况，队尾追加
* 所以能不用则不用

## 3.7.增加多个元素

### 3.7.1extend

* extend(iterable)

原理

将可迭代对象全部取出后，尾部追加到列表中

```python
ls1 = list(range(3))
ls1.extend([1,2,3])
# [1,2,3,1,2,3]

相当于 for i in [1,2,3]:
    	ls1.append(i)
```

## 3.8.