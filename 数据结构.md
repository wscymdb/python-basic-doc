# 1.内建常用的数据类型

* 序列（sequence）类型
  * 字符串str、字节序列bytes、bytearry
  * 列表list、元组tuple
* 键值对
  * 集合set、字典dict

# 2.线性数据结构

## 2.1.线性表

​	简称表，是一种抽象的数学概念，是一组元素的```序列```的抽象，由有穷个元素组成（0个或任意个）

序列：可以编号的，但是不一定是顺序的

分为顺序表和链接表

* 顺序表（list）：使用一大块```连续的内存储```表中的元素，这样实现的表称之为顺序表，或称连续表（内存是连续编地址的，顺序表就是利用这点，所以速度块）
  * 在顺序表中，元素的关系使用顺序表的存储顺序自然地表示
* 链接表(linked list)：在```存储空间中```将```分散存储```的元素链接起来，这种实现称为链接表，简称```链表```
  * 链表是线性结构，内存分布上看着不连续，但是内部有指向，前一个元素指向下一个元素，所以他是有明确顺序的

# 3.列表list

* 属于线性表的```顺序表```
* 使用```[]```表示
* 元素可以是任意对象
* 列表是可索引的，从索引从```0```开始
* 列表是``可变的``

## 3.2.列表的初始化

* []    空列表
* list()  空列表
* [1,2,'a',True]
* list()
  * 括号中写可迭代对象

```python
l1 = []  # []
l2 = list() #[]
l3 = [1,2,3,'a'] # [1,2,3,'a']
l4 = list(range(3)) # [0，1，2]
# 从range(3)中遍历所有元素，组成一个新的列表，然后返回给14
l5 = list([1,'a']) # [1,'a']
# 从[1,'a']中遍历所有元素，组成一个新的列表，然后返回给15
```

## 3.3.索引

* 有负的索引，从-1开始
* 正索引从0开始，索引范围[0, length-1]
* 索引超出list的length，会抛出异常
* 用索引访问list的元素，``效率高``，时间复杂度为``O(1)``

```python
l1 = [1, 2, 'a', True, None]
print(l1[-1]) # None
print(l1(6))  # TypeError: 'list' object is not callable
```

## 3.4.查询

* 遍历元素都跟当前遍历的例表的数据的个数有关，元素多称为``规模大``,反之称为``规模小``
* O(1) ：1是一个``常数``，可以是一步或者``固定的几步``，与规模n无关，不会随着规模n的增加而影响效率
* O(n)  ：耗时随着n的规模增加而增加

### 3.4.1.index

使用：

* index(value [,start [,stop] ] )
* 通过值value，从指定区间查找列表内的元素是否匹配
* 匹配第一个就立即返回索引
* 匹配不到，抛出异常``ValueError``

```python 
l1 = [1, 2, 2, 'a', None]
idx = l1.index('a')
# 2
```



总结：

* 耗时随着数据规模的增加而增加
* 效率随着规模的增加而下降,效率``极差``
* 时间复杂度是``O(n)``
* ``数据规模大时，不推荐使用``

### 3.4.2count

使用:

* count(value)
* 返回列表中匹配value的次数

总结：

* 不管有多少元素都需要完整的遍历一遍
* 数据规模有多大，耗时就有多久，效率也就``极差``
* 时间复杂度是``O(n)``
* ``数据规模大时，不推荐使用``

```python
l1 = [1, 2, 2, 'a', None]
cnt = l1.count(2)
# 2
```



### 3.4.3.len

获取当前list的长度，时间复杂度是``O(1)``

时间复杂度是O(1)的原因：

​	因为len()不是通过遍历list去获取长度的，而是包装c语言的数组，每当list中``新增``一个元素就让list的``长度+1``，如果``删除``的话就``让长度-1``，所以当调用len的时候，就会直接返回长度了

```python
l1 = [1,2,3]
len(l1) # 3
```

## 3.5.修改

* 通过索引定位到元素，然后直接赋值即可，注意索引不能超界
* ``时间复杂度是O(1)``

```python
ls1 = [1,2,3]
ls1[0] = 9
# [9, 2, 3]
```

## 3.6.增加单个元素

### 3.6.1.append （尾部追加）

```python
ls1 = [1, 2]
ls1.append(1)
# [1,2,1]
```



append函数没有返回值，返回值是None（一般说没有返回值），没有返回值往往表示它自己被改变了，``就地修改``

* 在元素``内部尾部``追加

**时间复杂度：**

``列表原理``

​	列表是一个容器，他是有容量的，python中列表可以扩大，自动扩大，会先给初始的大小，不够了会扩容，每次扩增的倍数是2倍。

**添加元素分为两种情况**

* 情况一
  * 列表的容量够时，通过找到下标，直接在内部尾部追加，此时的``时间复杂度是O(1)``

* 情况二
  * 列表容量不够时，会先将列表的容量进行扩充，在执行添加操作，此时的``时间复杂度是O(n)``。

**扩容时分为两种情况**

* 情况一：连续内存够时
  * 因为列表时顺序表，顺序表的特点是在内存中找到连续内存，当列表需要扩容时，如果当前连续内存后面还有未被使用的内存时，那么直接扩容
* 情况二：连续内存不够时
  * 当扩容时，如果当前内存后面没有空闲的内存时，那么就涉及到python的垃圾回收机制了，扩容会等到垃圾回收机制将当前连续的内存后面的内容清理出来，才会执行扩容行为，这个等待的时间时耗时的，所以效率就低了

总结：

* 一般情况下，定位效率高
* 定位（通过下标找到元素）

### 3.6.2.insert

* insert(index, object)
* 在索引index的``前面插入``object
* 超界（右边），相当于append的效果
* 超界（左边），插入的元素在下标为0的地方显示

```python

ls1 = [1, 2, 3]
ls1.insert(-1, 'p')
# [1, 2, 'p', 3]
ls1.insert(1, 'p')
# [1, 'p', 2, 3]

# 超右边界
ls1.insert(100, 'p')
# [1, 2, 3, 'p']

# 超左边界
ls1.insert(-100, 'p')
# ['p', 1, 2, 3]
```

总结

* insert的``定位效率高``
* 插入点之后有数据向后``挪动``，``效率极低``。
* 规模越大，挪动数据越多
* 最差的情况，插入到队首
* 最好的情况，``队尾追加``
* 所以``能不用则不用``

## 3.7.增加多个元素

### 3.7.1.extend

* extend(iterable)
* 追加规模不大的情况下，效率高

原理

将可迭代对象全部取出后，尾部追加到列表中

```python
ls1 = list(range(3))
ls1.extend([1,2,3])
# [1,2,3,1,2,3]

相当于 for i in [1,2,3]:
    	ls1.append(i)
```

## 3.8.特殊符号

### 3.8.1. +

当``+``用在``列表``的时候:

* 将两个列表连接在一起，返回一个``新的list``
* 属于浅拷贝

```python
l1 = [1, 2, 3]
l2 = [4, 5, 6]
# l1 + l2 = [1, 2, 3, 4, 5, 6]
```

### 3.8.2. *

当``*``用在``列表``的时候:

* 将列表``重n次``，返回一个``新的list``
* 属于浅拷贝

```python
l3 = [1, 2] * 2
# l3:  [1,2,1,2,1,2]
```

如果``重复``的内容是``引用类型``的话，新数组的``内容的地址是相同的``

```python
# 因为重复的是[1] 地址相同，所以改变其中一项其余的都改变
l2 = [[1]] * 3
l2[1][0] = 100
# l2 = [[100], [100], [100]]
```

## 3.9.删除

### 3.9.1. remove

* remove(value)
* 因为找值(非找下标)的过程是需要遍历的，所以时间复杂度是``O(1)``
* 没有返回值（none）

```python
l1 = [1, 'rr', 'ss']
l1.remove('rr')
```

### 3.9.2. pop

* pop( [index] )
* ``查找``的时间复杂度是``O(1)``
* 给定下标删除的时候，如果是``删除非尾部``的元素(会引起挪动)，时间复杂度是``O(n)``
* ``没有给定索引``，默认删除``尾部``，时间复杂度是``O(1)``
* 返回值是删除的当前元素

```python
l1 = ['a', 'b', 'c']
l1.pop(1)  # 'b'   l1 : ['a', 'c']
```

### 3.9.3.clear

* clear()
* 时间复杂度是``O(1)``
* 删除所有的数据，慎用，内存是宝贵的，好不容易放在列表中，慎用
* 返回值是none

## 3.10.反转

### 3.10.1.reverse

* 将列表元素反转，返回值是None
* 就地修改
* 这个方法最好不用，可以倒着读取，都不要反转

## 3.11.排序

### 3.11.1.sort

* sort(key=None, reverse=False)
* 返回值是None
* reverse为True，降序排序，不写（默认是升序）
* key是一个函数，指定key如何排序

## 3.12.操作符

### 3.12.1. in

* 规模大时候，效率低下，因为要遍历
* 比较元素时，先比较地址，再比较内容，有一个一样的返回的是True

```python
-1 in [1, 2, 3]
# False
[1] in [[1], 2, 3]
# True
```



## 3.13.复制

### 3.13.1. is 和 ==

- ``==``内容相同即可，地址不一定相同

  - 如果比较的两者是``引用类型``的，如果发现``类型相同``，那么会找到``引用类型的内容``进行比较，判断内容是否相等

  - ```python
    [1, [1,2], 3] == [1, [1, 2], 3]
    True
    ```

- ``is``  内容和地址都相同，才是相同

- 使用内建函数``id``可以查看内存地址

### 3.13.2. copy

* 浅拷贝
* 两个内存地址不一样

```python
x = [1, 2, 3]
y = x.copy()
x == y  # True
x is y # False
```

### 3.13.2. deepcopy

* 深拷贝
* deep模块下的深拷贝

```python
import copy

a = [1, [2,[3,4]], 3]
b = copy.deepcopy(a)
a[1][1][1] = 'aa'
print(a)   # [1, [2, [3, 'aa']], 3]
print(b)  # [1, [2, [3, 4]], 3]
```

# 4.链接表

## 4.1.CRUD效率问题

* 元素规模较大时，``增删频繁``，尽量使用``链接表``
* 修改元素时，链接表的效率``不如``列表，列表通过索引找元素，链表通过遍历

### 4.1.1.增加

* ``定位数据``是遍历index的，时间复杂度是``O(n)``
* 找到后，``插入数据``，就是指向断开，重新指向别的，时间复杂度是``O(1)``
* 链表的头尾操作效率更高，因为不需要遍历首尾
* 中间操作需要遍历找到元素，然后在执行插入操作

### 4.1.2.删除

* 头尾移除效率很高
* 中间操作，要遍历找到被删除的元素，找到后，断开连接，再重新连接

### 4.1.3.修改

* 找到元素是需要遍历，才能找到索引
* 查找元素的时间复杂度是``O(n)``

### 4.1.4.查找

* 需要遍历找到元素
* 时间复杂度是``O(n)``

### 4.14.5.遍历

* 和数据规模有关
* 只要是遍历，时间复杂度是``O(n)``

# 5.栈(Stack)

**``栈和队列都只能进行首位操作，不能进行中间操作``**

* 后进先出 LIFO（last in first out）
* 队尾操作，链接表和列表效率差不多
* 所以使用列表和链接表都行

# 6.队列(Queue)

**``栈和队列都只能进行首位操作，不能进行中间操作``**

* 先进先出 FIFO
  * 因为是先进先出（队首操作），如果使用列表的话，会造成挪动，效率地下
  * 所以``使用的链接表完成的``
* 后进先出 LIFO
  * 队尾操作，链接表和列表效率差不多
  * 所以使用列表和链接表都行